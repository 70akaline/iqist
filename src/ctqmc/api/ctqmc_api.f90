!!!-----------------------------------------------------------------------
!!! project : lilac
!!! program : api
!!!           api@T_solver
!!!           api@T_segment_solver
!!!           api@T_general_solver
!!!           api@T_segment_azalea
!!!           api@T_segment_gardenia
!!!           api@T_segment_narcissus
!!!           api@T_general_begonia
!!!           api@T_general_lavender
!!!           api@T_general_pansy
!!!           api@T_general_manjushaka
!!!           api@T_mpi
!!!           api@init_ctqmc
!!!           api@exec_ctqmc
!!!           api@stop_ctqmc
!!!           api@set_hybf
!!!           api@set_symm
!!!           api@set_eimp
!!!           api@get_grnf
!!!           api@get_sigf
!!! source  : ctqmc_api.f90
!!! type    : module
!!! author  : li huang (email:huangli712@gmail.com)
!!! history : 01/07/2014 by li huang
!!!           01/11/2014 by li huang
!!!           08/07/2014 by li huang
!!! purpose : the purpose of this module is to define a generic and robust
!!!           application programming interface (CAPI) for continuous-time
!!!           quantum Monte Carlo impurity solver
!!! status  : unstable
!!! comment :
!!!-----------------------------------------------------------------------

!!
!!
!! Introduction
!! ============
!!
!! This module can provide a light weight interface (i.e., application
!! programming interface, API) for fortran 90 language to the ctqmc quantum
!! impurity solver. The user can use it to access the AZALEA, GARDENIA,
!! NARCISSUS, BEGONIA, LAVENDER, PANSY, and MANJUSHAKA codes.
!!
!! Usage
!! =====
!!
!! In the following, we will use AZALEA code as an example to show how to
!! use api to control it.
!!
!! 1. import api support
!! ---------------------
!!
!! use api
!!
!! 2. create T_mpi
!! ---------------
!!
!! type (T_mpi) :: I_mpi           ! define I_mpi
!! ...
!! call mp_init()                  ! init mpi environment
!! call mp_comm_rank(I_mpi%myid)   ! init I_mpi structure
!! call mp_comm_size(I_mpi%nprocs) ! init I_mpi structure
!!
!! Note: The above codes need MPI support. Namely, you have to import the
!! mpi support explicitly.
!!
!! use mmpi
!!
!! 3. create T_segment_azalea
!! --------------------------
!!
!! type (T_segment_azalea) :: I_solver ! define I_solver
!! ...
!! I_solver%isscf  = 1                 ! setup I_solver
!! I_solver%issun  = 1
!! I_solver%isspn  = 2
!! I_solver%isbin  = 1
!! I_solver%nband  = 1
!! I_solver%nspin  = 2
!! I_solver%norbs  = 2
!! I_solver%ncfgs  = 4
!! I_solver%niter  = 20
!! I_solver%mkink  = 1024
!! I_solver%mfreq  = 8193
!! I_solver%nfreq  = 128
!! I_solver%ntime  = 1024
!! I_solver%nflip  = 10000
!! I_solver%ntherm = 20000
!! I_solver%nsweep = 20000000
!! I_solver%nwrite = 2000000
!! I_solver%nclean = 20000
!! I_solver%nmonte = 100
!! I_solver%ncarlo = 100
!!
!! I_solver%U     = 4.0
!! I_solver%Uc    = 4.0
!! I_solver%Uv    = 4.0
!! I_solver%Jz    = 0.0
!! I_solver%Js    = 0.0
!! I_solver%Jp    = 0.0
!! I_solver%mune  = 2.0
!! I_solver%beta  = 10.0
!! I_solver%part  = 0.50
!! I_solver%alpha = 0.50
!!
!! Note: If you want to use the other solvers, instead of AZALEA code,
!! please choose suitable solver type.
!!
!! Note: Every parameter for quantum impurity solver must be initialized
!! here.
!!
!! 4. init the ctqmc impurity solver
!! ---------------------------------
!!
!! call init_ctqmc(I_mpi, I_solver)
!!
!! 5. setup hybf, symm, and eimp
!! -----------------------------
!!
!! For examples:
!!
!! integer :: size_t
!! complex(dp) :: hybf(size_t)
!! ...
!! call set_hybf(size_t, hybf) ! setup hybridization function: hybf
!!
!! Note: This step is optional, because the ctqmc will provide default
!! values for hybf, symm, and eimp.
!!
!! 6. start the ctqmc impurity solver
!! ----------------------------------
!!
!! call exec_ctqmc(i)
!!
!! Here i is the current iteration number.
!!
!! 7. retrieve the calculated results
!! ----------------------------------
!!
!! Through this api, the user can only access the sigf (i.e., self-energy
!! function) and grnf (i.e., impurity Green's function) directly. As for
!! the other physical observables, the user should check the other output
!! files generated by iQIST.
!!
!! integer :: size_t
!! complex(dp) :: grnf(size_t)
!! call get_grnf(size_t, grnf)
!!
!! 8. close the ctqmc impurity solver
!! ----------------------------------
!!
!! call stop_ctqmc()
!!
!! 9. finialize the mpi environment
!! --------------------------------
!!
!! call mp_barrier()
!! call mp_finalize()
!!
!! Note: This step is also optional.
!!
!!

  module api
     implicit none

!!========================================================================
!!>>> declare global parameters                                        <<<
!!========================================================================

! dp: number precision, double precision for reals
     integer, private, parameter :: dp = kind(1.0d0)

!!========================================================================
!!>>> declare global data structure                                    <<<
!!========================================================================

! define type T_mpi, which is used to describe the mpi environment
     type :: T_mpi
         integer :: nprocs
         integer :: myid
         integer :: master
         integer :: cid
         integer :: cx
         integer :: cy
     end type T_mpi

! define type T_solver, which is used to describe the generic abstract
! ctqmc impurity solver
! note: it can not be used directly
     type :: T_solver
         integer :: isscf
         integer :: issun
         integer :: isspn
         integer :: isbin
         integer :: nband
         integer :: nspin
         integer :: norbs
         integer :: ncfgs
         integer :: niter
         integer :: mkink
         integer :: mfreq
         integer :: nfreq
         integer :: ntime
         integer :: nflip
         integer :: ntherm
         integer :: nsweep
         integer :: nwrite
         integer :: nclean
         integer :: nmonte
         integer :: ncarlo

         real(dp) :: U
         real(dp) :: Uc
         real(dp) :: Uv
         real(dp) :: Jz
         real(dp) :: Js
         real(dp) :: Jp
         real(dp) :: mune
         real(dp) :: beta
         real(dp) :: part
         real(dp) :: alpha
     end type T_solver

! define type T_segment_solver, which is used to describe the ctqmc
! impurity solver which based on segment representation
! note: it can not be used directly
     type, extends (T_solver) :: T_segment_solver
         character(len=10) :: solver_type = 'SEGMENT'
     end type T_segment_solver

! define type T_general_solver, which is used to describe the ctqmc
! impurity solver which based on general matrix formulation 
! note: it can not be used directly
     type, extends (T_solver) :: T_general_solver
         character(len=10) :: solver_type = 'GENERAL'
     end type T_general_solver

! define type T_segment_azalea, which is used to describe the ctqmc
! impurity solver code azalea
     type, extends (T_segment_solver) :: T_segment_azalea
         character(len=10) :: solver_name = 'AZALEA'
         integer :: solver_id = 101
         integer :: solver_is_ready = 1
     end type T_segment_azalea

! define type T_segment_gardenia, which is used to describe the ctqmc
! impurity solver code gardenia
     type, extends (T_segment_solver) :: T_segment_gardenia
         character(len=10) :: solver_name = 'GARDENIA'
         integer :: solver_id = 102
         integer :: solver_is_ready = 1

         integer :: isort
         integer :: isvrt
         integer :: lemax
         integer :: legrd
         integer :: chmax
         integer :: chgrd
         integer :: nffrq
         integer :: nbfrq
     end type T_segment_gardenia

! define type T_segment_narcissus, which is used to describe the ctqmc
! impurity solver code narcissus
     type, extends (T_segment_solver) :: T_segment_narcissus
         character(len=10) :: solver_name = 'NARCISSUS'
         integer :: solver_id = 103
         integer :: solver_is_ready = 1

         integer :: isort
         integer :: isvrt
         integer :: isscr
         integer :: lemax
         integer :: legrd
         integer :: chmax
         integer :: chgrd
         integer :: nffrq
         integer :: nbfrq

         real(dp) :: lc
         real(dp) :: wc
     end type T_segment_narcissus

! define type T_general_begonia, which is used to describe the ctqmc
! impurity solver code begonia
     type, extends (T_general_solver) :: T_general_begonia
         character(len=10) :: solver_name = 'BEGONIA'
         integer :: solver_id = 201
         integer :: solver_is_ready = 1

         integer :: nzero
         integer :: npart
     end type T_general_begonia

! define type T_general_lavender, which is used to describe the ctqmc
! impurity solver code lavender
     type, extends (T_general_solver) :: T_general_lavender
         character(len=10) :: solver_name = 'LAVENDER'
         integer :: solver_id = 202
         integer :: solver_is_ready = 1

         integer :: isort
         integer :: isvrt
         integer :: nzero
         integer :: lemax
         integer :: legrd
         integer :: chmax
         integer :: chgrd
         integer :: nffrq
         integer :: nbfrq
         integer :: npart
     end type T_general_lavender

! define type T_general_pansy, which is used to describe the ctqmc
! impurity solver code pansy 
! TODO
     type, extends (T_general_solver) :: T_general_pansy
         character(len=10) :: solver_name = 'PANSY'
         integer :: solver_id = 301
         integer :: solver_is_ready = 1
     end type T_general_pansy

! define type T_general_manjushaka, which is used to describe the ctqmc
! impurity solver code manjushaka
! TODO
     type, extends (T_general_solver) :: T_general_manjushaka
         character(len=10) :: solver_name = 'MANJUSHAKA'
         integer :: solver_id = 302
         integer :: solver_is_ready = 1
     end type T_general_manjushaka

!!========================================================================
!!>>> declare accessibility for module routines                        <<<
!!========================================================================

     private :: T_solver
     private :: T_segment_solver
     private :: T_general_solver

     public  :: T_segment_azalea
     public  :: T_segment_gardenia
     public  :: T_segment_narcissus

     public  :: T_general_begonia
     public  :: T_general_lavender

     public  :: T_general_pansy
     public  :: T_general_manjushaka

     public  :: T_mpi

     public  :: init_ctqmc
     public  :: exec_ctqmc
     public  :: stop_ctqmc

     public  :: set_hybf
     public  :: set_symm
     public  :: set_eimp

     public  :: get_grnf
     public  :: get_sigf

  contains ! encapsulated functionality

!!>>> init_ctqmc: initialize the ctqmc quantum impurity solver
  subroutine init_ctqmc(I_mpi, I_solver)
     implicit none

! external arguments
! type structure of mpi
     class(*), intent(in) :: I_mpi

! type structure of generic solver
     class(*), intent(in) :: I_solver

     call cat_init_ctqmc(I_mpi, I_solver)

     return
  end subroutine init_ctqmc

!!>>> exec_ctqmc: execute the ctqmc quantum impurity solver
  subroutine exec_ctqmc(iter)
     implicit none

! external arguments
! current iteration number
     integer, intent(in) :: iter

     call cat_exec_ctqmc(iter)

     return
  end subroutine exec_ctqmc

!!>>> stop_ctqmc: stop the ctqmc quantum impurity solver
  subroutine stop_ctqmc()
     implicit none

     call cat_stop_ctqmc()

     return
  end subroutine stop_ctqmc

!!>>> set_hybf: setup the impurity hybridization function
  subroutine set_hybf(size_t, hybf_t)
     implicit none

! external arguments
! size of hybf
     integer, intent(in)     :: size_t

! hybridization function
     complex(dp), intent(in) :: hybf_t(size_t)

     call cat_set_hybf(size_t, hybf_t)

     return
  end subroutine set_hybf

!!>>> set_symm: setup the symmetry vector
  subroutine set_symm(size_t, symm_t)
     implicit none

! external arguments
! size of symm
     integer, intent(in) :: size_t

! symmetry vector
     integer, intent(in) :: symm_t(size_t)

     call cat_set_symm(size_t, symm_t)

     return
  end subroutine set_symm

!!>>> set_eimp: setup the impurity energy level
  subroutine set_eimp(size_t, eimp_t)
     implicit none

! external arguments
! size of eimp
     integer :: size_t

! impurity energy level
     real(dp) :: eimp_t(size_t)

     call cat_set_eimp(size_t, eimp_t)

     return
  end subroutine set_eimp

!!>>> get_grnf: extract the impurity green's function
  subroutine get_grnf(size_t, grnf_t)
     implicit none

! external arguments
! size of grnf
     integer, intent(in)      :: size_t

! impurity green's function
     complex(dp), intent(out) :: grnf_t(size_t)

     call cat_get_grnf(size_t, grnf_t)

     return
  end subroutine get_grnf

!!>>> get_sigf: extract the self-energy function
  subroutine get_sigf(size_t, sigf_t)
     implicit none

! external arguments
! size of sigf
     integer, intent(in)      :: size_t

! self-energy function
     complex(dp), intent(out) :: sigf_t(size_t)

     call cat_get_sigf(size_t, sigf_t)

     return
  end subroutine get_sigf

  end module api
